list：
    1. 优先用列式推导，相比于for loop
        - 因为list comprehension更快，代码整洁
        - 不用每次循环都做if 判断

dict：
    2. 创建字典也可以用字典推导

    3. 可哈希的，意味着不可变的（也可比较的），也就是可以作为字典的key来用的

    4. 字典的获取，改变和删除操作都是O(1), 但是遍历和复制是O(n)，而且这个n是曾经出现的所有n，如果曾经有过很多值后来删了很多，建议使用新的

    5. 字典的key的顺序不是一定的，如果需要有序可以使用collections中的OrderedDict

集合
    set-可变的
    fronzenset-不可变的，所以可以作为dict的键

collections moudule
    deque
    defaultdict-有默认value的dict
    Counter-计数
    OrderedDict-有序字典

yield
    - 是什么？
        a generator， it can stop a function and return a intermediate result， make code simple and preformance
    - 举例：
        //斐波那契数列
        def fibonacci():
            a,b = 0,1
            while True:
                yield b
                a,b = b, a+b
        可以使用next()或者for循环来从generator中获取元素，比如：
        fib = fibonacci()
        next(fib) => 1
        [next(fib) for _ in range(10)] => [1,2,3,5,8...]
    - 为什么高效？
        当序列元素被传递到另一个函数中以进行后续处理时，一次返回一个会更高效
        这样就相当于提供了一个缓冲区，由另外的代码去控制，像上面的函数不需要无限大的内存去存结果
        当两个generator函数组合使用的时候，每次next()都处理一个元素调用两个结果然后返回，详见P42

装饰器